module AnalyticalIncident

using Gridap
using SpecialFunctions
using FFTW

export u_incident_modes, exact_solution_som, exact_quadratic_pml

##IMPLEMENT A MODULE OF THIS AS SOON AS POSSBILE, CLEARLY IF ONLY  THE NECCESARY FUNCTIONS ARE INCLUDED WHEN THE FILE IS IMPORTED, ALSO THE COMPUTATION TIME WILL BE REDUCED!!!!

"""
Functions to compute the analytical solution of the incident field in the bi-layer problem using the tranlation of the solution of a monopole source in the fluid domain.
"""
    
    """
    This function computes the solution of the pressure field generated by a monopole source ubicated at the free surface of the fluid domain.
    """
    function π₀(x, x₀, y₀, tP, tF, L, kF)
        if (abs(x[1]) <= L/2 && x[2] > 0 && (x[2]-(tP+tF)) < 0)
            return 1im/4 * hankelh1(0, kF * sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2))
        else
            return 0. + 0.0im
        end
    end

    """
    This function computes the solution of the displacement field generated by a monopole source ubicated at the free surface of the fluid domain.
    """
    function uF_radial(x, x₀, y₀, tP, tF, L, kF, ρF, ω)
        if (abs(x[1]) <= L/2 && x[2] > 0 && (x[2]-(tP+tF)) < 0)
            ux = -1im * kF/(4*ρF*ω^2) * hankelh1(1, kF*sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)) * (x[1]-x₀) / sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)
            uy = -1im * kF/(4*ρF*ω^2) * hankelh1(1, kF*sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)) * (x[2]-y₀) / sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)
        else
            ux = 0. + 0.0im
            uy = 0. + 0.0im
        end
        return VectorValue(ux, uy)
    end

    """
    Source term for the porous domain when the translation is done using the radial solution of the fluid domain.
    """
    function fₚ(x, x₀, y₀, tp, L, ω₀, ρP, cP, kF)
        if (abs(x[1]) <= L/2 >= 0 && (x[2]-tp) <= 0 && x[2] >= 0)
            ux = (-ω₀^2*ρP - kF^2*ρP*cP^2) * -1im * kF/4 * hankelh1(1, kF*sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)) * (x[1]-x₀) / sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)
            uy = (-ω₀^2*ρP - kF^2*ρP*cP^2) * -1im * kF/4 * hankelh1(1, kF*sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)) * (x[2]-y₀) / sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2)
        else
            ux = 0. + 0.0im
            uy = 0. + 0.0im
        end
        return VectorValue(ux, uy)  
    end

"""
Functions to compute the the solution of the analytical incident field using dynamic mode decomposition of Fourier modes of a monopole source ubicanted in the free-
surface of the fluid domain.
"""
    
    """
    end_fire_array(Nₛ::Int, Δy::Float64, kF::Float64, ρ_F::Float64, ω::Float64) -> VectorValue

    Calculate the complex pressure field produced by an end-fire array of point sources. The array is linear, with sources
    equally spaced vertically along the y-axis, and all having the same x-coordinate.

    # Arguments
    - `Nₛ::Int`: Number of sources in the array.
    - `Δy::Float64`: Vertical spacing between adjacent sources in the array.
    - `kF::Float64`: Wave number of the fluid field.
    - `ρ_F::Float64`: Density of the fluid medium.
    - `ω::Float64`: Angular frequency of the wave.
    """
    function u_end_fire_array(x, Nₛ, xᵦ, yᵦ, Δy, kF, ρ_F, ω)
        
        ypos = [yᵦ - i*Δy for i in 0:(Nₛ-1)]
        xpos = fill(xᵦ, Nₛ)
        A = fill(1/Nₛ, Nₛ)
        
        ux = -1im * kF/(4*ρ_F*ω^2) * sum(A[j]*hankelh1(1, kF*sqrt((x[1]-xpos[j])^2 + (x[2]-ypos[j])^2)) * (x[1]-xpos[j]) / sqrt((x[1]-xpos[j])^2 + (x[2]-ypos[j])^2) for j in eachindex(ypos))
        uy = -1im * kF/(4*ρ_F*ω^2) * sum(A[j]*hankelh1(1, kF*sqrt((x[1]-xpos[j])^2 + (x[2]-ypos[j])^2)) * (x[2]-ypos[j]) / sqrt((x[1]-xpos[j])^2 + (x[2]-ypos[j])^2) for j in eachindex(ypos))

        return VectorValue(ux, uy)       
    end

    function π_end_fire_array(x, Nₛ, xᵦ, yᵦ, Δy, kF)
        
        ypos = [yᵦ - i*Δy for i in 0:(Nₛ-1)]
        xpos = fill(xᵦ, Nₛ)
        A = fill(Aₛ, Nₛ)
        
        πF = 1im/4 * sum(A[j]*hankelh1(0, kF*sqrt((x[1]-xpos[j])^2 + (x[2]-ypos[j])^2)) for j in eachindex(ypos))
            # 1im/4 * hankelh1(0, kF * sqrt((x[1]-x₀)^2 + (x[2]-y₀)^2))
        return πF       
    end

    function compute_π0_coefs(N, L, d_PML, xᵦ, yᵦ, k_F)
        
        a = L/2 + d_PML # Half of interval length
        h_fft = 2*a / N # Grid step size
        x_points = -a:h_fft:a-h_fft # Discretization of the interface domain [m]
        
        πF(x, xᵦ, yᵦ, k_F) = 1im/4 * hankelh1(0, k_F * sqrt((x-xᵦ)^2 + (t_P-yᵦ)^2))

        πF_I = map(x -> πF(x, xᵦ, yᵦ, k_F), x_points)

        # Compute the Fourier coefficients of the input data and normalize by N using the FFT
        π0 = fft(πF_I) ./ N

        return π0
    end

    function compute_u0_coefs(N, L, d_PML, xᵦ, yᵦ, ρ_F, k_F, ω)
        
        a = L/2 + d_PML # Interval length
        h_fft = 2*a / N # grid size
        x_points = -a:h_fft:a-h_fft # Discretization of the interface domain [m], with size N

        uF(x, xᵦ, yᵦ, ρ_F, k_F) = -1im*k_F/(4*ρ_F*ω^2) * hankelh1(1, k_F * sqrt((x-xᵦ)^2 + (t_P-yᵦ)^2)) * (t_P-yᵦ)  / sqrt((x-xᵦ)^2 + (t_P-yᵦ)^2)

        uF_I = map(x -> uF(x, xᵦ, yᵦ, ρ_F, k_F), x_points)

        # Compute the Fourier coefficients of the input data and normalize by N using the FFT
        u0 = fft(uF_I) ./ N
    
        # Compute the frequencies associated with the Fourier coefficients
        k = 2*π*fftfreq(N, 1)./h_fft

        return u0, k
    end

    function compute_scat_coefs(π0, u0, ρ_F, ρ_P, βF, βP, ω)
        
        # Coefficients of the 2x2 linear system associated with the conditions at the interface
        A = 1\(ρ_F*ω^2).*βF
        B = -1\(ρ_P*ω^2).*βP

        # Solution of the 2x2 linear system
        πF_s = (B.*π0 - u0) ./ (A .- B)
        πP = πF_s .+ π0

        return πF_s, πP
    end

    function uF_s(x, a, t_P, βF, πF_s, k, ρ_F, ω)
        
        ux = 1/(ρ_F*ω^2) * sum(πF_s[j] * 1im * k[j] * exp(βF[j] * (x[2]-t_P)) * exp(1im*k[j]*(x[1]+a)) for j in eachindex(βF))
        uy = 1/(ρ_F*ω^2) * sum(πF_s[j] * βF[j] * exp(βF[j] * (x[2]-t_P)) * exp(1im*k[j]*(x[1]+a)) for j in eachindex(βF))
        
        return VectorValue(ux, uy)
    
    end

    function uP(x, a, t_P, βP, πP, k, ρ_P, ω)
        
        ux = 1/(ρ_P*ω^2) * sum(πP[j] * 1im * k[j] * exp(βP[j] * (x[2]-t_P)) * exp(1im*k[j]*(x[1]+a)) for j in eachindex(βP))
        uy = 1/(ρ_P*ω^2) * sum(πP[j] * βP[j] * exp(βP[j] * (x[2]-t_P)) * exp(1im*k[j]*(x[1]+a)) for j in eachindex(βP))
        
        return VectorValue(ux, uy)
        
    end

    function πP_inc(x, a, t_P, βP, πP, k)
        return sum(πP[j] * exp(βP[j] * (x[2]-t_P)) * exp(1im*k[j]*(x[1]+a)) for j in eachindex(βP))
    end

    function u_incident_modes(x, t_P, t_F, L, a, βP, πP, k, ρ_P, βF, πF_s, ρ_F, ω)
        
        if (abs(x[1]) <= L/2  && (x[2]-t_P) < 0 && x[2] >= 0)
            return uP(x, a, t_P, βP, πP, k, ρ_P, ω) 
        elseif (abs(x[1]) <= L/2  && (x[2]-t_P) >= 0 &&  (x[2]-(t_P+t_F)) < 0)
            return uF_s(x, a, t_P, βF, πF_s, k, ρ_F, ω)
        else
            return VectorValue(0., 0.)
        end
    end

"""
This function implements the analytical solution for the incident field in the two domain problem using the Sommerfeld boundary condition.
"""
function exact_solution_som(x, ρ_F, c_F, k_F, ρ_P, c_P, k_P, P_0, t_F, t_P, d_PML, σ_0)

    # Characteristic impedance at the fluid and porous domains
    Z_F = ρ_F * c_F
    Z_P = ρ_P * c_P

    # Source term
    α = P_0/(1im*ω*Z_F)
    
    # Fluid amplitudes
    A_F = (Z_F-Z_P)/Z_F * α * exp(1im*t_F*k_F)/((Z_F+Z_P)/Z_F*exp(1im*t_P*k_F)+(Z_P-Z_F)/Z_F*exp(1im*(2*t_F+t_P)*k_F))
    B_F = A_F*exp(2im*(t_F+t_P)*k_F) + α*exp(1im*(t_F+t_P)*k_F)
    
    # Porous amplitudes
    B_P = (A_F*(exp(1im*t_P*k_F)+exp(1im*(2*t_F+t_P)*k_F))+α*exp(1im*t_F*k_F))*exp(1im*t_P*k_P) 
   
    # Evaluation at fluid, porous and bottom PML
    if (abs(x[1]) <= L/2 && x[2] - t_P >= 0 && (x[2]-(t_P+t_F)) < 0)
        return VectorValue(0., A_F * exp(1im * k_F * x[2]) + B_F * exp(-1im * k_F * x[2])) # fluid domain
    elseif (abs(x[1]) <= L/2 && x[2] - t_P < 0 && x[2]>0)
        return VectorValue(0., B_P * exp(-1im * k_P * x[2])) # porous domain
    else
        # return VectorValue(0., B_P * exp(-1im * k_P * x[2]) * exp(σ_0/3*(x[2]^3)/d_PML^2)) # bottom PML (x[2]<0)
        return VectorValue(0., 0.) # bottom PML (x[2]<0)
    end
end

function sommerfeld_scat(x, ρ_F, c_F, k_F, ρ_P, c_P, k_P, P_0, t_F, t_P)

    # Characteristic impedance at the fluid and porous domains
    Z_F = ρ_F * c_F
    Z_P = ρ_P * c_P

    # Source term
    α = P_0/(1im*ω*Z_F)
    
    # Fluid amplitudes
    A_F = (Z_F-Z_P)/Z_F * α * exp(1im*t_F*k_F)/((Z_F+Z_P)/Z_F*exp(1im*t_P*k_F)+(Z_P-Z_F)/Z_F*exp(1im*(2*t_F+t_P)*k_F))
    B_F = A_F*exp(2im*(t_F+t_P)*k_F) + α*exp(1im*(t_F+t_P)*k_F)
    
    # Porous amplitudes
    B_P = (A_F*(exp(1im*t_P*k_F)+exp(1im*(2*t_F+t_P)*k_F))+α*exp(1im*t_F*k_F))*exp(1im*t_P*k_P) 
   
    # Evaluation at fluid, porous and bottom PML
    if (abs(x[1]) <= L/2 && x[2] - t_P >= 0 && (x[2]-(t_P+t_F)) < 0)
        return VectorValue(0., A_F * exp(1im * k_F * x[2])) # fluid domain
    elseif (abs(x[1]) <= L/2 && x[2] - t_P < 0 && x[2]>0)
        return VectorValue(0., B_P * exp(-1im * k_P * x[2])) # porous domain
    else
        # return VectorValue(0., B_P * exp(-1im * k_P * x[2]) * exp(σ_0/3*(x[2]^3)/d_PML^2)) # bottom PML (x[2]<0)
        return VectorValue(0., 0.) # bottom PML (x[2]<0)
    end
end


"""
This function implements the calculation of the coefficients of the analytical solution for the incident field in the two domain problem using the
Perfectly Matched Layer (PML) boundary condition.
"""
    function solve_coefficients_pml(ω, Z_F, Z_P, P_0, t_P, t_F, k_F, k_P, σ_0, d_PML)
        
        # Matrix of the system
        M = Complex{Float64}[
            exp(1im*(t_P+t_F)*k_F) -exp(-1im*(t_P+t_F)*k_F) 0 0 0 0;
            exp(1im*t_P*k_F) exp(-1im*t_P*k_F) -exp(1im*t_P*k_P) -exp(-1im*t_P*k_P) 0 0;
            exp(1im*t_P*k_F) -exp(-1im*t_P*k_F) -Z_P/Z_F*exp(1im*t_P*k_P) Z_P/Z_F*exp(-1im*t_P*k_P) 0 0;
            0 0 1 1 -1 -1; 
            0 0 1 -1 -1 1;
            # 0 0 0 0 1 0]  
            0 0 0 0 exp(-1im * k_P * d_PML)*exp(d_PML*σ_0/3) exp(1im * k_P * d_PML)*exp(-d_PML*σ_0/3)]

        # Independent term of the linear system
        b = Complex{Float64}[
            -P_0 / (1im*ω*Z_F),
            0,
            0,
            0,  
            0,  
            0   
        ]

        
        solution = M \ b

        A_F = solution[1]
        B_F = solution[2]
        A_P = solution[3]
        B_P = solution[4]
        A_PML = solution[5]
        B_PML = solution[6]

        return A_F, B_F, A_P, B_P, A_PML, B_PML
    end

    function exact_quadratic_pml(x, t_P, k_F, k_P, d_PML, σ_0, A_F, B_F, A_P, B_P, A_PML, B_PML)
        if (abs(x[1]) <= L/2 && x[2] - t_P >= 0 && (x[2]-(t_P+t_F)) < 0)
            return VectorValue(0., A_F * exp(1im * k_F * x[2]) + B_F * exp(-1im * k_F * x[2]))
        elseif (abs(x[1]) <= L/2 && x[2] - t_P < 0 && x[2]>0)
            return  VectorValue(0., A_P * exp(1im * k_P * x[2]) + B_P * exp(-1im * k_P * x[2]))
        else
            # return  VectorValue(0., A_PML * exp(1im * k_P * x[2]) * exp(-σ_0/3*(x[2]^3)/d_PML^2) + B_PML * exp(-1im * k_P * x[2]) * exp(σ_0/3*(x[2]^3)/d_PML^2))
            return  VectorValue(0., 0.)
        end
    end

end